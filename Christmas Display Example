
//The LED strip instance pointer
LEDSegs* strip;

const short nTotalLEDs = 158 + 160; //Total number of LEDs in the strip (160 for a 5-meter 32/meter strip uncut)
const short nFirstLED = 0; //First LED to turn on (0-origin)
const short nLastLED = nTotalLEDs - 1; //Max LED index to illuminate. Must be < nTotalLEDs
const unsigned long refreshDelayMS = 30; //Min time between strip update cycles (in milliseconds)
const unsigned long segmentSetDisplayTimeMS = 45 * 1000; //Amount of time to display each segment set
unsigned long waitforSegmentTimeMS, thisSegmentSet; //Keeps track of which segment set we're doing and how long

//This is an array of segment display setup subroutines that are selected by the
//four toggle switches. When the state of the switches changes, the current strip setup
//is cleared, and the corresponding setup routine here is called to change the display

typedef void (*SegmentSetupRoutine) ();
static SegmentSetupRoutine SegmentSetups[] = {
  SegmentProgramChristmas1,
  SegmentProgramChristmas2,
  SegmentProgramChristmas3,
  SegmentProgramChristmas4,
  SegmentProgramChristmas5, 
  SegmentProgramChristmas6,
  SegmentProgramChristmas7,
  SegmentProgramChristmas8,
};

//Total number of segment sets (segment definition routines) in the above array

const short nSegmentSets = sizeof(SegmentSetups) / sizeof(SegmentSetups[0]);

/*
SegmentProgramChristmas1: 5 simple segments
*/

void SegmentProgramChristmas1() {
  short nLEDsPerSegment, iSegment;
  const short nSegments = 5;
  const short bands[nSegments] = {cSegBand2, cSegBand3, cSegBand4, cSegBand5, cSegBand6};
  uint32_t Colors5[nSegments] = {RGBRed, RGBGold, RGBPurple, RGBGreen, RGBBlue};

  //segments of equal # of LEDs.
  nLEDsPerSegment = (nLastLED - nFirstLED + 1) / nSegments;

  //Define the active segments
   for (iSegment = 0; iSegment < nSegments; iSegment++) {
    strip->DefineSegment((iSegment*nLEDsPerSegment)+nFirstLED, nLEDsPerSegment, cSegActionFromMiddle, Colors5[iSegment], bands[iSegment]);
    strip->SetSegment_BackColor(strip->GetSegmentIndex(), RGBWhiteVeryDim);
  }
}

/*
SegmentProgramChristmas2: Pulsing solid color all spectra -- Choose a new color each call
*/

void SegmentProgramChristmas2() {
  short nLEDs;
  const short nColors = 6;
  uint32_t foreColors[nColors] = {RGBRed, RGBGreen, RGBBlue, RGBGold, RGBPurple, RGBWhiteDim};
  static short thisColor = -1;

  thisColor = (thisColor + 1) % nColors;  
  nLEDs = nLastLED - nFirstLED + 1;

  strip->DefineSegment(nFirstLED, nLEDs, cSegActionStatic, foreColors[thisColor], 0x1E);
  strip->SetSegment_Options(strip->GetSegmentIndex(), cSegOptModulateSegment);
  strip->SetSegment_DisplayRoutine(&DisplayRoutineModulateHelper);
}

//The LED intensity isn't linear with level, so this display routine provides segments that are
//defined as static/modulate with better "action"
void DisplayRoutineModulateHelper(short iSegment) {
  const short nCuts = 9;
  const short C2CutLevels[nCuts] = { 80, 150, 225, 400, 500, 600, 700, 800, 950};
  const short C2MapLevels[nCuts] = {  0,   1,   4,  10,  50, 200, 400, 700, cMaxSegmentLevel};
  short iLevel, thisLevel;
  thisLevel = strip->GetSegment_Level(iSegment);
  for (iLevel = 0; iLevel < (nCuts-1); iLevel++) {
    if (thisLevel < C2CutLevels[iLevel]) {break;}
  }
  strip->SetSegment_Level(C2MapLevels[iLevel]);
}

/*
SegmentProgramChristmas3: Two interleaved red/green solid segments for all spectra, green one inverted
*/

void SegmentProgramChristmas3() {
  short nLEDs = nLastLED - nFirstLED + 1;

  strip->DefineSegment(nFirstLED, nLEDs, cSegActionFromMiddle, RGBRed, cSegBand2 | cSegBand3);
  strip->SetSegment_Spacing(strip->GetSegmentIndex(), 1);
  strip->SetSegment_BackColor(strip->GetSegmentIndex(), RGBBlueDim);

  strip->DefineSegment(nFirstLED + 1, nLEDs - 1, cSegActionFromMiddle, RGBGreen, cSegBand4 | cSegBand5 | cSegBand6);
  strip->SetSegment_Spacing(strip->GetSegmentIndex(), 1);
  strip->SetSegment_BackColor(strip->GetSegmentIndex(), RGBBlueDim);
}

/*
SegmentProgramChristmas4: Three segments
*/

void SegmentProgramChristmas4() {
  short nLEDs = nLastLED - nFirstLED + 1;
  short nLEDsPerSegment = nLEDs / 3;

  strip->DefineSegment(nFirstLED, nLEDsPerSegment, cSegActionFromTop, RGBRed, 0x02);
  strip->SetSegment_BackColor(strip->GetSegmentIndex(), RGBBlueVeryDim);
  strip->SetSegment_Options(strip->GetSegmentIndex(), cSegOptModulateSegment);

  strip->DefineSegment(nFirstLED + nLEDsPerSegment + 1, nLEDsPerSegment, cSegActionFromMiddle, RGBGold, 0x0C);
  strip->SetSegment_BackColor(strip->GetSegmentIndex(), RGBBlueVeryDim);
  strip->SetSegment_Options(strip->GetSegmentIndex(), cSegOptModulateSegment);

  strip->DefineSegment(nFirstLED + (2*nLEDsPerSegment) + 1, nLEDsPerSegment, cSegActionFromBottom, RGBGreen, 0x30);
  strip->SetSegment_BackColor(strip->GetSegmentIndex(), RGBBlueVeryDim);
  strip->SetSegment_Options(strip->GetSegmentIndex(), cSegOptModulateSegment);
}

/*
SegmentProgramChristmas5: 5 interleaved segments (my favorite)
*/

void SegmentProgramChristmas5() {
  short nLEDsPerSegment, iSegment;
  const short nSegments = 5;
  const short bands[] = {cSegBand2, cSegBand3, cSegBand4, cSegBand5, cSegBand6};
  uint32_t Colors5[] = {RGBRed, RGBYellow, RGBPurple, RGBBlue, RGBGreen};

  nLEDsPerSegment = (nLastLED - nFirstLED + 1);

  //Define the active segments
   for (iSegment = 0; iSegment < nSegments; iSegment++) {
    strip->DefineSegment(nFirstLED + iSegment, nLEDsPerSegment, cSegActionFromMiddle, Colors5[iSegment], bands[iSegment]);
    strip->SetSegment_Spacing(strip->GetSegmentIndex(), nSegments-1);
  }
}

/*
SegmentProgramChristmas6: Adjacent segments with a custom display routine
*/

const short nSegmentsChristmas6 = 8;
short levelsChristmas6[nSegmentsChristmas6 + 1];

void SegmentProgramChristmas6() {
  short nLEDsPerSegment, iSegment, levelRangePerSegment, nLevel;
  nLEDsPerSegment = (nLastLED - nFirstLED + 1) / nSegmentsChristmas6;
  levelRangePerSegment = cMaxSegmentLevel / nSegmentsChristmas6;
  nLevel = 0;
  
  //Define the active segments
   for (iSegment = 0; iSegment < nSegmentsChristmas6; iSegment++) {
    strip->DefineSegment(nFirstLED + (iSegment * nLEDsPerSegment), nLEDsPerSegment, cSegActionStatic, RGBBlue, 0x3E);
    strip->SetSegment_DisplayRoutine(iSegment, &SegmentDisplayChristmas6);
    levelsChristmas6[iSegment] = nLevel;
    nLevel += levelRangePerSegment;
  }
  levelsChristmas6[nSegmentsChristmas6] = cMaxSegmentLevel;
}

void SegmentDisplayChristmas6(short iSegment) {
  short curLevel;
  curLevel = strip->GetSegment_Level(iSegment);
  strip->SetSegment_Action(iSegment, cSegActionStatic);
  if ((levelsChristmas6[iSegment] >= curLevel) || (levelsChristmas6[iSegment+1] < curLevel)) {strip->SetSegment_Action(iSegment, cSegActionNone);}
}

/*
SegmentProgramChristmas7: A single, sliding segment of fixed length, starting position depends on level
*/

const short C7SegLen = 50;  //The length of the "slider"
const short C7SegMinLevel = 80; //The min level needed to show the slider
short C7ColorSegs[3];  //Records the index of the three 0-length color segments
uint32_t C7SegColors[3] = {RGBRed, RGBGreen, RGBGold};  //Color based on which band is loudest

void SegmentProgramChristmas7() {
  
  //Define a background for the whole strip
  strip->DefineSegment(nFirstLED, nTotalLEDs, cSegActionStatic, RGBBlueVeryDim, 0);

  //Define the slider segment. It's color and starting position are set in the display routine
  strip->DefineSegment(0, C7SegLen, cSegActionStatic, RGBBlue, 0x1E);
  strip->SetSegment_DisplayRoutine(&SegmentDisplayChristmas7);

  //Define three zero-length segments just to get the levels for the three bands we want to
  //check to set the color of the motion segment in the display routine
  C7ColorSegs[0] = strip->DefineSegment(0, 0, cSegActionNone, RGBRed, cSegBand2);
  C7ColorSegs[1] = strip->DefineSegment(0, 0, cSegActionNone, RGBGreen, cSegBand3);
  C7ColorSegs[2] = strip->DefineSegment(0, 0, cSegActionNone, RGBBlue, cSegBand4 | cSegBand5);
}

void SegmentDisplayChristmas7(short iSegment) {
  short curLevel, startPos;
  uint32_t thiscolor;
  short colorseg, iseg, maxcolorlevel, thislevel;
  curLevel = strip->GetSegment_Level(iSegment) - C7SegMinLevel;

  maxcolorlevel = -1; colorseg = 0;
  for (iseg = 0; iseg < 3; iseg++) {
    thislevel = strip->GetSegment_Level(C7ColorSegs[iseg]);
    if (thislevel > maxcolorlevel) {maxcolorlevel = thislevel; colorseg = iseg;}
  }

  if (curLevel < 0) {strip->SetSegment_Action(iSegment, cSegActionNone);}
  else {
    strip->SetSegment_Action(iSegment, cSegActionStatic);
    strip->SetSegment_ForeColor(iSegment, C7SegColors[colorseg]);
    startPos = ((curLevel * (nTotalLEDs - C7SegLen)) /
        (cMaxSegmentLevel - C7SegMinLevel)) + nFirstLED;
    startPos = constrain(startPos, 0, nLastLED); //safety
    strip->SetSegment_FirstLED(iSegment, startPos);
  }  
}
/*
SegmentProgramChristmas8: Single color-modulated segment based on sound level
*/

void SegmentProgramChristmas8() {
  strip->DefineSegment(0, nTotalLEDs, cSegActionStatic, RGBOff, cSegBand2 | cSegBand3 | cSegBand4 | cSegBand5);
  strip->SetSegment_DisplayRoutine(&SegmentDisplayChristmas8);
}

//Display routine to modulate the color.
void SegmentDisplayChristmas8(short iSegment) {
  const short C8nColors = 3;
  static const short C8ColorLow[C8nColors] = {0, 550, 700};     //RGB
  static const short C8ColorPeak[C8nColors] = {100, 750, 1023};
  static const short C8ColorHigh[C8nColors] = {600, 800, 1023};
  short C8RGBLevels[C8nColors];
  short iColor, seglevel, lowval, peakval, highval;

  seglevel = strip->GetSegment_Level(iSegment);  
  for (iColor = 0; iColor < C8nColors; iColor++) {
    lowval = C8ColorLow[iColor];
    peakval = C8ColorPeak[iColor];
    highval = C8ColorHigh[iColor];
    C8RGBLevels[iColor] = 0;
    if (seglevel > lowval) {
      if (seglevel < peakval) {C8RGBLevels[iColor] = ((seglevel - lowval) * 127) / (peakval - lowval);}
      else if (seglevel < highval) {C8RGBLevels[iColor] = ((highval - seglevel) * 127) / (highval - peakval);}
    }
  }
  strip->SetSegment_ForeColor(iSegment, LEDSegs::Color(C8RGBLevels[0], C8RGBLevels[1], C8RGBLevels[2])); 
}

/*
SegmentProgramNothing: A do-nothing placeholder for the function array when no program is defined for
the given combination of switches
*/

void SegmentProgramNothing(short iSegment) {
}

/*
The Arduino boot setup routine
*/

void setup() {

  //Create the strip class instance we will use
  strip = new LEDSegs(nTotalLEDs);
  
  //Make sure we see a "change" to start the segment sets cycling
  thisSegmentSet = -1;
  waitforSegmentTimeMS = 0;

}

/*
The Arduino main loop. Just sample and display with a wait
*/

void loop() {
  uint32_t startRefreshMS;       //MS time at the start of this refresh cycle;

  //Get the current time 
  startRefreshMS = millis();

  //If time for this segment set has run out, reset thetimer and move to the next segment set (cyclic)
  if (waitforSegmentTimeMS <= startRefreshMS) {
    waitforSegmentTimeMS = startRefreshMS + segmentSetDisplayTimeMS; //Set the time for the upcoming segment set
    thisSegmentSet++; //Move to the next segment set (cycling)
    if (thisSegmentSet >= nSegmentSets) {thisSegmentSet = 0;};
    strip->ResetStrip();
    SegmentSetups[thisSegmentSet]();
  }  
  
  //Do the deed
  strip->DisplaySpectrum(true, true);

  //Wait for the minimum refresh time;
  while (millis() < (startRefreshMS + refreshDelayMS)) {;}
}
